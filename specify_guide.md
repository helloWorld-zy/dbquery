## 1) 目标与范围（MVP → 可扩展）

- **MVP**：支持 PostgreSQL 的连接管理、元数据浏览（table/view/column/关系）、SQL 查询（仅 SELECT）、自然语言生成 SQL、结果表格展示与导出。
- **可扩展目标**：后续可按“数据库适配器（Adapter/Plugin）”方式加入 MySQL / MariaDB / SQL Server / SQLite / Oracle / Snowflake 等，而不重写业务层与 UI。

------

## 2) 总体架构（分层 + 可插拔适配器）

### 2.1 后端分层

- **API 层（FastAPI）**：只负责输入校验、鉴权策略（本项目为无认证）、返回统一 JSON 结构、错误码映射、请求追踪 ID。
- **领域服务层（Services）**：连接管理、元数据同步、查询执行、SQL 校验与重写、LLM 生成 SQL、历史记录等核心逻辑都在这一层，避免与具体数据库耦合。
- **适配器层（DB Adapters）**：每种数据库实现一套统一接口：
  - 连接可用性检测
  - 元数据抓取（schemas/tables/views/columns/keys/relationships/comments）
  - 方言声明（dialect）
  - 查询执行（含超时、取消、游标/分页能力）
  - 结果类型映射（日期、数值、JSON、二进制等）
- **持久化层（SQLite Repository）**：存储连接配置、元数据缓存、查询历史、LLM 生成记录、刷新状态等；提供事务、版本迁移、并发保护。

> 关键原则：业务层只依赖“适配器接口”和“元数据统一模型”，不依赖 PostgreSQL 专有 SQL。

### 2.2 可扩展点（为多数据库预留）

- 引入“**能力矩阵**”概念：不同数据库/驱动在元数据丰富度、取消查询、估算行数、视图定义获取等方面能力不同；通过适配器声明 capabilities，前端/服务层据此降级展示或关闭某些按钮。
- **统一元数据规范化模型**：不把 DB 原始输出直接透传给前端；先归一化为统一结构，再由前端展示，确保新增数据库时 UI 不变或最小变更。
- **方言隔离**：sqlglot 的 dialect 由适配器提供；LLM 提示词中明确“目标方言”。

------

## 3) 数据存储设计（SQLite 作为本地控制面 + 缓存）

### 3.1 存什么

- **连接信息**：db url（敏感部分加密或至少本地安全存储策略）、名称、类型（postgres/mysql/…）、创建/最近使用、连接测试结果。
- **元数据缓存**（可复用、可增量刷新）：
  - schema 列表
  - table/view 列表
  - columns（类型、可空、默认值、注释、顺序）
  - 主键/唯一键/索引（如果可得）
  - 外键关系（用于 join 推荐与 ER 展示）
  - 可选：表/列的“语义描述”（由 LLM 生成）
- **查询历史**：SQL、来源（手写/自然语言）、执行耗时、返回行数、错误信息、执行时间、连接 ID。
- **元数据同步状态**：上次刷新时间、刷新耗时、是否失败、失败原因、元数据版本号（用于兼容未来模型升级）。

### 3.2 两层元数据：确定性 + LLM 增强（推荐）

- **确定性元数据（必须）**：直接来自数据库系统目录/信息架构，保证准确、可重放、可对比差异。
- **LLM 增强元数据（可选）**：在不改变事实的前提下生成“描述/用途猜测/业务含义”，单独字段存储，并带上生成时间与模型版本，便于将来重新生成或清理。

> 这样既满足你“LLM 转 JSON 可复用”的方向，又避免把事实结构交给 LLM 生成而导致不稳定。

### 3.3 缓存策略

- 默认优先使用 SQLite 中的元数据缓存；用户可手动刷新。
- 可选自动刷新：连接首次使用/缓存过期（例如 24h）时触发后台刷新，但仍用旧缓存服务，刷新完成后切换版本。
- 支持“增量刷新/差异对比”（后续）：只更新变化的表列，避免全量成本。

------

## 4) 元数据抓取（PostgreSQL MVP + 多数据库抽象）

### 4.1 PostgreSQL 需覆盖的信息

- 用户 schema 下的 tables/views（排除系统 schema）
- 列信息（类型、nullable、default、comment）
- 约束：PK、FK、Unique
- 可选：索引、视图定义（用于高级调试/展示）、行数估算（用于 UI 排序/提示）

### 4.2 统一输出结构（供前端与 LLM）

- 元数据应同时提供两种视角：
  1. **树形导航视角**：schema → table/view → columns
  2. **关系视角**：表之间 FK 图（join 依据）
- 元数据要包含“可用于 prompt 的精简版”：避免把过大的元数据原封不动塞给 LLM（成本与上下文限制）。精简版按用户当前关注的 schema/表进行裁剪。

------

## 5) SQL 执行链路（校验、限制、重写、运行、返回）

### 5.1 输入处理与安全约束

- 所有 SQL（手写与 LLM 生成）在执行前统一走：
  1. **解析**：sqlglot[rs] 解析为 AST，捕获并返回明确的语法错误（含定位信息，便于编辑器标红）。
  2. **语义限制**：仅允许单条 `SELECT`（含 WITH/CTE 也算 SELECT 体系），拒绝 DDL/DML/多语句/隐式写入（如 `SELECT INTO` 视具体方言策略禁止）。
  3. **强制限制**：如无 LIMIT，自动追加 `LIMIT 1000`；如有 LIMIT 但超过阈值可警告或强制上限（配置项）。
  4. **可选：只读会话保障**：建议数据库侧使用只读账号；应用侧也可设置事务只读（能力取决于数据库）。

### 5.2 执行与资源控制

- 必须有：
  - **超时**（例如 30s，可配置）
  - **最大返回行数**（与 LIMIT 协同）
  - **最大列数/单元格大小**（避免极端大字段拖垮前端）
- 查询取消：
  - 适配器声明是否支持 cancel；支持则暴露“取消当前 query”的后端能力，前端提供按钮。
- 结果输出统一 JSON：
  - 包含 `columns`（name/type）与 `rows`
  - 类型处理一致：时间 ISO8601；Decimal/BigInt 以字符串或安全数值策略；二进制 Base64 或省略并提示；JSON/ARRAY 保持结构或字符串化（可配置）

------

## 6) 自然语言生成 SQL（LLM 交互规范）

### 6.1 上下文构造（关键：可扩展、可控）

- Context 分层：
  - 必选：目标数据库类型/方言、当前连接名称、可用 schema 列表
  - 优先：用户当前选中的 schema 或 table 的精简元数据
  - 可选：FK 关系图摘要、常见业务实体描述（来自 LLM 增强字段）
- 上下文裁剪策略：
  - 默认仅提供“相关表集合”（由用户选择/搜索/最近浏览推断）
  - 元数据过大时按权重截断：表名与列名优先，注释与描述次之

### 6.2 输出约束

- LLM 只返回 SQL（不带解释文本），并明确要求：
  - 仅 SELECT
  - 使用目标方言
  - 尽量显式 schema 限定
  - 尽量引用存在的列/表（否则宁可提问澄清）
- 生成后仍必须走同一条 sqlglot 校验链路；校验失败时：
  - 给用户展示可读错误
  - 允许“一键重试生成”（把错误信息与解析失败原因作为反馈）

### 6.3 交互体验

- 生成 SQL 不自动执行（避免误跑大查询）；用户确认后执行。
- 支持“在当前 SQL 上修改”模式（多轮）：用户输入“加上按天分组/增加过滤条件”，系统把当前 SQL 与新需求一起给 LLM，产出修订版 SQL。

------

## 7) 前端体验（React + refine + antd + tailwind + monaco）

### 7.1 页面与组件

- 连接管理页：新增/测试/删除/选择连接，显示元数据更新时间与状态。
- 主工作台：
  - 左侧：元数据树（schema/tables/views/columns），支持搜索与收藏常用表
  - 中间：Monaco SQL 编辑器（多 Tab、格式化、错误标注、补全）
  - 下方或右侧：结果表格（antd Table），支持排序/分页（前端分页仅用于展示，后端由 LIMIT 控制）、复制、导出
  - 顶部：自然语言输入区 + “生成 SQL”按钮

### 7.2 编辑器增强

- 自动补全的数据源来自后端元数据缓存（避免每次实时查库）
- 解析错误定位：后端返回的错误位置映射到 Monaco diagnostics
- 当后端自动添加 LIMIT 时，前端提示“已自动添加 LIMIT 1000”，并展示最终执行 SQL（可展开查看）

------

## 8) 配置与运行约束

- 环境配置：Ollama、模型名、默认超时、默认 LIMIT、最大 LIMIT、是否允许导出、元数据刷新策略等。
- 日志与可观测性：
  - 每次连接测试、元数据刷新、查询执行、LLM 调用都记录结构化日志（不记录明文密码；SQL 也可脱敏/可配置）
  - 为每个请求生成 requestId，便于排查
- 错误模型统一：前端能区分“连接失败/元数据失败/SQL 语法错误/权限错误/超时/LLM 失败”。

